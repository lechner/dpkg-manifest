#!/usr/bin/perl
#
# dpkg-manifest
#
# Copyright Â© 2017 Felix Lechner <felix.lechner@lease-up.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

use strict;
use warnings;

use feature qw(switch);
no if $] >= 5.018, warnings => "experimental::smartmatch";

use Carp;
use File::Find::Rule;
use Fcntl ':mode';
use File::LibMagic;
use Digest::SHA;

# module version
our $VERSION = 0;

# file types
my $REGULAR          = q{Regular};
my $DIRECTORY        = q{Directory};
my $LINK             = q{Link};
my $CHARACTER_DEVICE = q{Character-Device};
my $BLOCK_DEVICE     = q{Block-Device};
my $FIFO             = q{Fifo};
my $SOCKET           = q{Socket};

my @FILE_TYPES = (
    $REGULAR, $DIRECTORY, $LINK, $CHARACTER_DEVICE, $BLOCK_DEVICE, $FIFO,
    $SOCKET,
);

# overall output fields
my $MANIFEST_VERSION  = q{Manifest-Version};
my $TITLE             = q(Title);
my $RUNNING_DIGEST    = q{Running-Digest};
my $DIGEST_COMPONENTS = q{Digest-Components};
my $ITEM              = q{Item};
my $TALLY             = q{Tally};

# per-file output fields
my $PATH              = q{Path};
my $FILE_TYPE         = q{File-Type};
my $CONTENT           = q{Content};
my $DESTINATION       = q{Destination};
my $OWNER             = q{Owner};
my $GROUP             = q{Group};
my $UID               = q{Uid};
my $GID               = q{Gid};
my $PERMISSIONS       = q{Permissions};
my $MODIFICATION_TIME = q{Modification-Time};

# extra information
my $MAGIC        = q{Magic};
my $MIME_TYPE    = q{Mime-Type};
my $ENCODING     = q{Encoding};
my $CONTENT_SIZE = q{Content-Size};

my @COMPONENTS = (
    $PATH,        $FILE_TYPE, $CONTENT, $DESTINATION,
    $OWNER,       $GROUP,     $UID,     $GID,
    $PERMISSIONS, $MODIFICATION_TIME,
);

# SHA digests
my @SHA_ALGOS = qw{SHA-256 SHA-384 SHA-512};

my $MODE_TO_TYPE = {
    S_IFREG()  => $REGULAR,
    S_IFDIR()  => $DIRECTORY,
    S_IFLNK()  => $LINK,
    S_IFCHR()  => $CHARACTER_DEVICE,
    S_IFBLK()  => $BLOCK_DEVICE,
    S_IFIFO()  => $FIFO,
    S_IFSOCK() => $SOCKET,
};

my $BASE64_WORDSIZE = 4;

sub pad_base64 {
    my ($padded) = @_;
    while ( length($padded) % $BASE64_WORDSIZE ) {
        $padded .= q{=};
    }
    return $padded;
}

sub scan_files {

    my ( $where, $include ) = @_;

    my $catalog = {};
    $catalog->{$ITEM}           = {};
    $catalog->{$RUNNING_DIGEST} = {};
    $catalog->{$TALLY}          = {};

    my $tally = $catalog->{$TALLY};

    my $magic = File::LibMagic->new();

    my $overallShaState = {};
    foreach my $algo (@SHA_ALGOS) {
        $overallShaState->{$algo} = Digest::SHA->new($algo);
    }

    # maybe use absolute file names?

    my @ITEMPATHS =
      sort File::Find::Rule->not( File::Find::Rule->name(q{.}) )->in($where);

    foreach my $systemPath (@ITEMPATHS) {

        my $cutlength = $where ne q{.} ? 1 + length $where : 0;
        my $catalogPath = q{./} . substr( $systemPath, $cutlength );

        # add path to digests
        foreach my $algo (@SHA_ALGOS) {
            $overallShaState->{$algo}->add($catalogPath);
        }

        my $item = {};
        $catalog->{$ITEM}{$catalogPath} = $item;

        my (
            $dev,  $ino,   $mode,  $nlink, $uid,     $gid, $rdev,
            $size, $atime, $mtime, $ctime, $blksize, $blocks
        ) = lstat($systemPath);

        $item->{$CONTENT_SIZE}      = $size;
        $item->{$MODIFICATION_TIME} = $mtime;
        $item->{$UID}               = $uid;
        $item->{$GID}               = $gid;
        $item->{$OWNER}             = getpwuid $uid;
        $item->{$GROUP}             = getgrgid $gid;
        $item->{$PERMISSIONS}       = sprintf "%04o", S_IMODE($mode);

        $item->{$FILE_TYPE} = $MODE_TO_TYPE->{ S_IFMT($mode) }
          or die "Unknown file type";

        $tally->{ $item->{$FILE_TYPE} } = 0
          if not defined $tally->{ $item->{$FILE_TYPE} };
        $tally->{ $item->{$FILE_TYPE} } += 1;

        given ( $item->{$FILE_TYPE} ) {

            when ($REGULAR) {
                $tally->{$CONTENT_SIZE} += $size;

                my $info = $magic->info_from_filename($systemPath);
                $item->{$MAGIC}     = $info->{description};
                $item->{$MIME_TYPE} = $info->{mime_type};
                $item->{$ENCODING}  = $info->{encoding};

                # calculate content digests
                $item->{$CONTENT} = {};
                foreach my $algo (@SHA_ALGOS) {
                    $item->{$CONTENT}{$algo} =
                      pad_base64( Digest::SHA->new($algo)->addfile($systemPath)
                          ->b64digest );
                }

                # also add content to overall digests
                foreach my $algo (@SHA_ALGOS) {
                    $overallShaState->{$algo}->addfile($systemPath);
                }

                # add other elements represented in manifest
            }

            when ($DIRECTORY) {
            }

            when ($LINK) {
                $tally->{$CONTENT_SIZE} += $size;
                my $destination = readlink $systemPath;
                $item->{$DESTINATION} = $destination;
                foreach my $algo (@SHA_ALGOS) {
                    $overallShaState->{$algo}->add($destination);
                }
            }

            when ($CHARACTER_DEVICE) {
            }

            when ($BLOCK_DEVICE) {
            }

            when ($FIFO) {
            }

            when ($SOCKET) {
            }

            default {
                croak 'Unknown file type';
            }
        }
    }

    foreach my $algo (@SHA_ALGOS) {
        $catalog->{$RUNNING_DIGEST}{$algo} =
          pad_base64( $overallShaState->{$algo}->b64digest );
    }

    return $catalog;
}

sub print_field {
    my ( $hashref, $field, $specifier ) = @_;
    if ( defined $specifier ) {
        print "$field: $specifier $hashref->{$field}{$specifier}\n"
          if defined $hashref
          && defined $hashref->{$field}
          && defined $hashref->{$field}{$specifier};
    }
    else {
        print "$field: $hashref->{$field}\n"
          if defined $hashref && $hashref->{$field};
    }
    return;
}

sub print_included_file_field {
    my ( $include, $item, $field, $specifier ) = @_;
    print_field( $item, $field, $specifier )
      if $include->{ $item->{$FILE_TYPE} }{$field};
    return;
}

sub write_manifest {
    my ( $catalog, $include, $title, $extra_info ) = @_;

    my $tally = $catalog->{$TALLY};

    print "$MANIFEST_VERSION: 0\n";
    print "$TITLE: $title\n" if defined $title;

    foreach my $algo (@SHA_ALGOS) {
        print_field( $catalog, $RUNNING_DIGEST, $algo );
    }

    foreach my $file_type (@FILE_TYPES) {
        if ( $tally->{$file_type} ) {
            print "$DIGEST_COMPONENTS: [$file_type] ",
              join( " ", @COMPONENTS ), "\n";
        }
    }

    if ($extra_info) {
        print "--- for information only ---\n";

        print "$TALLY: $ITEM ", scalar keys %{ $catalog->{$ITEM} }, "\n";

        foreach my $file_type (@FILE_TYPES) {
            print_field( $catalog, $TALLY, $file_type );
        }

        print_field( $catalog, $TALLY, $CONTENT_SIZE );
    }

    foreach my $catalogPath ( sort keys %{ $catalog->{$ITEM} } ) {

        my $item      = $catalog->{$ITEM}{$catalogPath};
        my $file_type = $item->{$FILE_TYPE};

        print "\n";

        foreach my $component (@COMPONENTS) {
            given ($component) {
                when ($PATH) {
                    print "$PATH: $catalogPath\n"
                      if $include->{$file_type}{$PATH};
                }
                when ($CONTENT) {
                    foreach my $algo (@SHA_ALGOS) {
                        print_included_file_field( $include, $item, $CONTENT,
                            $algo );
                    }
                }
                default {
                    print_included_file_field( $include, $item, $component );
                }
            }
        }

        if ($extra_info) {
            print "--- for information only ---\n";

            given ( $item->{$FILE_TYPE} ) {
                when ($REGULAR) {
                    print_field( $item, $MAGIC );
                    print_field( $item, $MIME_TYPE );
                    print_field( $item, $ENCODING );
                    print_field( $item, $CONTENT_SIZE );
                }
                when ($LINK) {
                    print_field( $item, $CONTENT_SIZE );
                }
            }
        }
    }

    return;
}

my $numArgs = $#ARGV + 1;

my $directory = q{.};
$directory = $ARGV[0] if ( $numArgs == 1 );

my $title = undef;

my $include = {};
foreach my $file_type (@FILE_TYPES) {
    $include->{$file_type} = {};
    foreach my $component (@COMPONENTS) {
        $include->{$file_type}{$component} = 0;
    }
}

foreach my $file_type (@FILE_TYPES) {
    $include->{$file_type}{$PATH}      = 1;
    $include->{$file_type}{$FILE_TYPE} = 1;
}

# regular files
$include->{$REGULAR}{$CONTENT} = 1;
$include->{$REGULAR}{$OWNER}   = 1;

# links
$include->{$LINK}{$DESTINATION} = 1;

my $extra_info = 1;

my $catalog = scan_files( $directory, $include );

# output results
write_manifest( $catalog, $include, $title, $extra_info );
