#!/usr/bin/perl
#
# dpkg-manifest
#
# Copyright Â© 2018 Felix Lechner <felix.lechner@lease-up.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

use strict;
use warnings;

use feature qw(switch);
no if $] >= 5.018, warnings => "experimental::smartmatch";

use Carp;

use lib q{.};
use Manifest::ScanFiles;
use Manifest::Write;

# module version
our $VERSION = 0;

# file types
my $REGULAR          = q{Regular};
my $DIRECTORY        = q{Directory};
my $LINK             = q{Link};
my $CHARACTER_DEVICE = q{Character-Device};
my $BLOCK_DEVICE     = q{Block-Device};
my $FIFO             = q{Fifo};
my $SOCKET           = q{Socket};

my @FILE_TYPES = (
    $REGULAR, $DIRECTORY, $LINK, $CHARACTER_DEVICE, $BLOCK_DEVICE, $FIFO,
    $SOCKET,
);

# overall output fields
my $MANIFEST_VERSION  = q{Manifest-Version};
my $TITLE             = q(Title);
my $RUNNING_DIGEST    = q{Running-Digest};
my $DIGEST_COMPONENTS = q{Digest-Components};
my $ITEM              = q{Item};
my $TALLY             = q{Tally};

# per-file output fields
my $PATH              = q{Path};
my $FILE_TYPE         = q{File-Type};
my $CONTENT           = q{Content};
my $DESTINATION       = q{Destination};
my $OWNER             = q{Owner};
my $GROUP             = q{Group};
my $UID               = q{Uid};
my $GID               = q{Gid};
my $PERMISSIONS       = q{Permissions};
my $MODIFICATION_TIME = q{Modification-Time};

# extra information
my $MAGIC        = q{Magic};
my $MIME_TYPE    = q{Mime-Type};
my $ENCODING     = q{Encoding};
my $CONTENT_SIZE = q{Content-Size};

my @FIELD_NAMES = (
    $PATH,        $FILE_TYPE, $CONTENT, $DESTINATION,
    $OWNER,       $GROUP,     $UID,     $GID,
    $PERMISSIONS, $MODIFICATION_TIME,
);


my $numArgs = $#ARGV + 1;

my $directory = q{.};
$directory = $ARGV[0] if ( $numArgs == 1 );

my $title = undef;

my $include = {};
foreach my $file_type (@FILE_TYPES) {
    $include->{$file_type} = {};
    foreach my $field_name (@FIELD_NAMES) {
        $include->{$file_type}{$field_name} = 0;
    }
}

foreach my $file_type (@FILE_TYPES) {
    $include->{$file_type}{$PATH}      = 1;
    $include->{$file_type}{$FILE_TYPE} = 1;
}

# regular files
$include->{$REGULAR}{$CONTENT} = 1;

#$include->{$REGULAR}{$OWNER}   = 1;

# links
$include->{$LINK}{$DESTINATION} = 1;

my $extra_info = 1;

my $catalog = scan_files( $directory, $include );

# warn if link is dangling or points outside of tree

# output results
write_manifest( $catalog, $include, $title, $extra_info );
